# 알고리즘
---
## 카운팅 정렬

집합 내의 가장 큰 정수를 알고 있고 n이 비교적 작을 때 사용하면 좋음

카운팅 정렬을 하기 위해서는 다음과 같은 준비가 필요함

입력 배열, 결과 배열, 카운트 배열

우선 카운트 배열을 최대값 + 1 만큼의 크기로 선언하는데 0으로 초기화함

입력 배열 길이만큼 카운트 배열에 숫자를 하나씩 카운트 할건데

카운트 배열의 인덱스에는 입력 배열의 값을 넣어 줌

예를들어 현재 입력 배열의 값이 10이라면 카운트 배열의 10번째 인덱스에 1을 더해주는 것임

다음 단계는 1부터 최대값까지 반복을 도는데

현재 카운트 배열의 값에 이전 카운트 배열 값을 더해줌

이제 카운트 배열의 값은 숫자가 존재해야 하는 위치를 가리키고 있음

그 다음 단계는 끝에서부터 반복을 도는데

입력 배열의 값을 결과 배열에다가 넣어줄 것임

결과 배열의 인덱스는 `(카운트 배열[입력 배열의 값])`인데

즉, 결과 배열에 숫자가 존재해야 하는 위치를 가리킨 후 숫자를 넣어주는 것임

자리가 찼으니 `(카운트 배열[입력 배열의 값])`은 하나 감소시키면 됨

## 유클리드 호제법

최대공약수를 구하기 위한 알고리즘

두 수가 있을 때 다음과 같은 방법으로 최대공약수를 구할 수 있다



```
a와 b의 최대공약수를 구해보자
b가 0이 될때까지 반복함
b의 값은 a를 b로 나눈 나머지를, a의 값은 원래의 b의 값으로 바꿔줌
a가 6이고 b가 15라면
a = 15, b = 6 % 15 즉, b = 3
b가 0이 아니므로 한번 더 반복하면 b가 0이되고 a는 3이됨
b가 0이 되었을 때 a값이 최대공약수
```

최대공약수를 구했다면 최소공배수도 다음과 같은 방법으로 구할 수 있다

```
최소공배수는 a와 b를 곱한 값을 최대공약수로 나누어준다
a가 6이고 b가 15일 때,
최대공약수는 3이므로
6 * 15 / 3 = 30
```

파이썬에서는 `from math import gcd, lcm` 등으로 쉽게 구할 수 있음

최대공약수를 찾을 때 만약 여러개의 수가 있다면 `gcd(a, gcd(b, gcd(c, d)))` 이런식으로 하면 구할 수 있음

직접 구현해봤는데 다음과 같이 하면 수가 아무리 많아도 최대공약수를 구할 수 있다

```python
def gcd(list):
    if len(list) < 2:
        return list
    else:
        a = list.pop()
        b = list.pop()
        while b:
            a, b = b, a % b
        list.append(a)
        return gcd(list)
```