# 알고리즘 문제 리뷰
---
## 백준 10989 정렬

[문제 링크](https://www.acmicpc.net/problem/10989)

오름차순 정렬인데 n이 크고 메모리를 적게 써야 함

메모리를 줄이는 방법은 append를 쓰지 않고 다음과 같은 방법을 써야 함

```python
import sys

count_list = [0] * 10001            # 최대값 + 1 만큼 배열 생성
                                    # 카운팅 정렬을 이용함
n = int(sys.stdin.readline())

for _ in range(n):
    num = int(sys.stdin.readline()) # sys.stdin.readline()을 이용해 빠르게 입력 받음
    count_list[num] += 1            # 숫자가 나온 횟수를 세줌

for x, k in enumerate(count_list):  # enumerate 함수는 반복가능한 배열을 인자로 받아 인덱스와 값을 함께 리턴함 
                                    # x와 k는 각각 인덱스와 값임
    if k != 0:                      # count_list의 값이 0이 아니면
        for _ in range(k):          # count_list의 값만큼 반복하여
            print(x)                # 인덱스를 출력 -> 인덱스가 숫자를 나타내기기 때문
```

## 백준 2839 최소 봉지의 개수

각각 무게가 3, 5인 봉지가 있는데 n만큼의 무게를 정확히 맞췄을 때 최소 봉지의 개수를 구해야 됨

정확히 맞추는 경우의 수가 없을 때는 -1을 출력해야 함

무게를 정확히 맞췄을 경우의 봉지의 개수를 저장할 리스트를 만들고

최대 봉지의 개수는 무게가 3인 봉지로만 구성했을 때니까

반복문은 `range(n // 3 + 1)`만큼 돌 것임

예를들어 무게가 15라면 다음과 같이 찾아봄

```
3
33
333
3333
33333
35
335
3335
33335
333335
355
3355
33355
333355
3333355
...
```

내가 짠 코드는 꽤 비효율적이라 조건 설정을 더 빡세게 해서 연산 횟수를 줄일수도 있음

어쨌든 반복문을 돌며 3과 5를 하나씩 증가시키다 보면 합산 무게가 목표 무게와 같아질 때가 있을텐데

이걸 리스트에 추가해줌

리스트가 비어있다면 정확히 무게를 맞춘 경우가 없는 것이므로 -1 출력하고

리스트가 들어있다면 그 중에 최소값을 출력

## 백준 18870 좌표 압축

문제 이해하는데 다른 문제보다 시간이 살짝 더 걸렸던 것 같다

숫자가 주어지는데 편차를 줄이라는 것이다

문제를 이해하고 난 뒤에는 숫자가 총 몇종류 등장하는지 알면 풀 수 있다고 생각함

그래서 중복을 제거해 새로운 배열을 만들고 오름차순으로 정렬함

나중에 새 리스트를 만들 때 딕셔너리를 이용한다면 속도가 빠를테니까

컴프리헨션을 이용해 리스트를 만들어줌

`compress = {num: x for x, num in enumerate(numbers)}`

enumerate 함수는 인덱스와 값을 내보내는 함수임

따라서 위의 식은 인덱스와 값을 (값 : 인덱스)의 딕셔너리를 만들어주는 것임

예를들면 입력이 `5 1 5 1 5`라면 중복 제거 후 `5 1`이 되고 오름차순 정렬해서 `1 5`가 됨

그 후 `enumerate` 함수에 넣으면 `(0, 1), (1, 5)`가 나올텐데

순서를 바꿔서 `compress`에는 `{1 : 0, 5 : 1}`로 들어감

마지막으로 기존 리스트를 수정해주는데

`arr = [comress[x] for x in arr]`

`compress`의 키와 동일한 숫자를 딕셔너리의 값으로 바꿔주게 됨

이어서 예를 들면 `5 1 5 1 5`의 1을 찾아 0으로 바꿔주고 5를 찾아 1로 바꿔주는 것임

리스트를 출력할 땐 `*`를 이용하면 띄어쓰기로 구분해 출력해줌

`print(*arr)`
