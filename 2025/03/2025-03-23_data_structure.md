# 자료구조
---
## 세그먼트 트리

원소 개수에 따라 트리의 크기가 정해짐
크기는 1부터 시작하여 원소 개수보다 작을 경우 계속 곱하기 2를 해줌

```c++
int size = 1;
int node = 8;
while (size < node) {
    size <<= 1;
}
// 1, 2, 4, 8
```

그후 트리의 전체 크기는 size * 2가 된다

실제로 데이터가 삽입되는 위치는 사이즈부터 시작된다

`data[i]`는 `tree[i+size]`로 삽입된다

부모노드는 해당 위치에서 나누기 2를 하면 됨

데이터 삽입이 일어나면 부모노드로 거슬러 올라가며 idx > 0이 될 때까지 필요한 연산을 한다

여기에 어떤 값을 넣느냐에 따라 다양한 세그먼트 트리를 만들 수 있음

쿼리는 왼쪽 포인터와 오른쪽 포인터를 조정하며 필요한 노드를 찾아 값을 더해준다

아래 행동을 왼쪽 포인터가 오른쪽 포인터를 초과하기 전까지 계속 반복한다

왼쪽 포인터의 경우, 홀수번째 노드이면 자기 자신을 더하고 오른쪽 형제 노드로 이동한 뒤 부모 노드로 이동한다

오른쪽 포인터의 경우, 짝수번째 노드이면 자기 자신을 더하고 왼쪽 형제 노드로 이동한 뒤 부모 노드로 이동한다

그 외의 경우는 아무것도 하지 않고 부모노드로 올라간다

## 펜윅 트리 BIT

원소 개수의 두배 크기만 있으면 됨

2의 보수를 이용해 부모노드를 찾아 올라가며 값을 업데이트 해줌

업데이트 연산은 현재 노드에 원하는 값을 더해준 뒤 2진수 상에서 가장 마지막에 있는 1값만큼 더해주어 부모노드를 찾아 계속 올라가며 업데이트 해줌

```c++
// update
while (index <= n) {
    tree[index] += delta;
    index += index & -index;
}
// index가 5라면 0101
// 0101의 2의 보수는 1010 + 1이므로 1011
// 여기에서 and 비트 연산을 하면 마지막에 있는 1이 무조건 나옴
```

쿼리는 인덱스를 빼면서 값을 더해주면 됨

```c++
// query
int sum = 0;
while (index <= n) {
    sum += tree[index];
    index -= index & -index;
}
return sum;
```

## 좌표 압축

원본 배열을 복사해서 정렬

중복을 제거하면 나중에 원본 배열과 복사된 배열을 이용해 압축된 좌표를 구할 수 있음

```c++
vector<int> arr;
// arr 입력
vector<int> sorted = arr;
// arr 복사
sort(sorted.begin(), sorted.end());
// 복사된 배열 정렬
sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());
// 중복 삭제

// 인덱스 찾기
int idx = lower_bound(sorted.begin(), sorted.end(), (찾을 값)) - sorted.begin();
// lower_bound는 이터레이터 형식을 반환하므로 시작 위치를 빼주어야 함
```