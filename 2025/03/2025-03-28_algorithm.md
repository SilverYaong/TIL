# 알고리즘
---
## 병합정렬

예전에는 이해가 잘 안되었는데 계속 공부하다 보니까 좀 익숙해졌음

두 가지 함수가 필요함

나누는 것과 합치는 것

우선 나누는 것부터

인덱스를 이용해서 나눌거임

왼쪽 인덱스가 오른쪽 인덱스보다 작으면 가운데를 설정하고 왼쪽부터 가운데까지, 가운데 + 1부터 오른쪽까지 분할함

그 후 합치는 함수로 보내면 됨

분할하는 코드는 다음과 같다

```c++
void partition(int l, int r) {
	if (l < r) {
		int mid = (l + r) / 2;
		partition(l, mid);
		partition(mid + 1, r);
		merge(l, r);
	}
}
```

합치는 부분 구현이 좀 많음

병합 과정에서 변수가 좀 많이 필요함

처음에 들어가는 왼쪽과 오른쪽의 범위는 정렬을 할 구간을 뜻함

인덱스를 조정해가며 결과값에 저장해야 하는데

i = 왼쪽 부분의 시작점, mid = 왼쪽 부분의 끝, j = 오른쪽 부분의 시작점, k를 결과값 인덱스를 나타낼 것임

오른쪽 부분의 끝은 처음에 주어지므로 따로 안만들어도 됨

이제 i가 mid보다 커지거나 j가 r보다 커지게 될때까지 반복

왼쪽 부분과 오른쪽 부분을 비교하여 왼쪽이 크면 오른쪽을 결과값에 넣고 오른쪽 인덱스과 결과값 인덱스를 증가

오른쪽이 크면 반대로 해줌

보통 이렇게 하면 한쪽이 남는데 while문으로 남은 부분을 결과값에 넣어주면 됨

그 후 원본 인덱스에 다시 복사해줌

오름차순이나 내림차순은 중간에 부등호 방향을 바꾸면 됨

응용해야되는 부분은 그때그때 코드를 수정해가며 값을 뽑아내면 됨

합치는 코드는 다음과 같다

```c++
void merge(int l, int r) {
    // 인덱스 변수들
	int i = l;
	int mid = (l + r) / 2;
	int j = mid + 1;
	int k = 0;
    // 임시 결과값
	vector<int> res(r - l + 1);
    // 비교하면서 결과값에 넣어줌
	while (i <= mid && j <= r) {
		if (arr[i] <= arr[j]) {
			res[k++] = arr[i++];
		}
		else {
			res[k++] = arr[j++];
		}
	}
    // 남은 숫자들 전부 넣음
	while (i <= mid) res[k++] = arr[i++];
	while (j <= r) res[k++] = arr[j++];
    // 원본 배열에 복사
	for (int t = 0; t < k; t++) arr[l + t] = res[t];
}
```
