# c++
---
## 백준 1774

최소신장트리 문제

좌표만 주어지고 이미 연결되어 있는 정점이 함께 주어진다

유니온파인드를 이용하는 크루스칼 알고리즘을 사용

이미 연결되어 있는 정점은 같은 그룹으로 처리해주고 나중에 경로를 확정할 때 다른 그룹일 때만 확정해주면 됨

크루스칼 알고리즘은 최소 비용의 간선을 우선적으로 선택하고 두 정점이 같은 그룹이 아닐때 같은 그룹으로 만들어 주고 경로를 확정한다

간선의 개수가 정점의 개수 - 1이 되면 최소신장트리가 완성된 것

좌표들을 입력 받고나면 연결되어 있는 정점이 주어지는데 이때 두 정점에 유니온 연산을 해서 같은 그룹으로 만들어 줌

모든 좌표들을 순회하며 좌표의 거리를 힙에 넣는데 `거리, 시작점, 도착점`으로 묶어 넣어 거리를 기준으로 정렬되도록 함

힙이 빌때까지 pop하면서 시작점과 도착점이 다른 그룹일때만 다음 연산을 진행

1. 같은 그룹으로 만들어줌

2. 간선개수 증가

3. 간선개수가 정점의 개수 - 1이면 반복문 종료

우리는 거리를 알아야 하니까 위 반복에서 결과값에 거리만 더해주면 됨

주요 코드 내용

```c++
// 유니온파인드
vector<int> p;

// 경로 압축이 적용된 찾기 연산
int unifind(int a) {
	if (p[a] < 0) return a;
	return p[a] = unifind(p[a]);
}

// 같은 그룹인지 확인하고 같은 그룹으로 만들어주는 연산
void uni(int a, int b) {
	a = unifind(a);
	b = unifind(b);
	if (a != b) p[b] = a;
}
```

```c++
// 크루스칼
// 변수 초기화
double ans = 0.0;
int edgeCount = 0;
while (!pq.empty()) {
	double d;
	int u, v;
	tie(d, u, v) = pq.top();
	pq.pop();
        // 같은 그룹이 아니면
	if (unifind(u) != unifind(v)) {
                // 같은 그룹으로 합침
		uni(u, v);
		ans += d;
                // 간선개수 증가
		edgeCount++;
                // 간선개수가 N-1이면 완성
		if (edgeCount == N - 1) break; 
	}
}
```

## 숫자 구분자

숫자 사이에 '를 넣으면 콤마로 구분되는 것처럼 읽기가 편해짐

```c++
#define MOD 1'000'000'007
```

## 최대값

limits 헤더파일을 써도 되지만 다른 방법도 있음

```c++
#define MAX (~0U >> 2)
```

해석하면 다음과 같다

`U`는 `unsigned int` 자료형을 나타내며 범위가 0부터 int형 최대값의 2배 + 1이다

근데 `0`에서 `~`를 사용해 비트를 반전시켰으므로 `~0U`는 `unsigned int`의 최대값이 된다

`>>`는 비트를 이동시키는 연산자로서 `num >> 1` 은 num의 비트를 오른쪽으로 1만큼 이동시키는 것이다

따라서 `~0U >> 2`는 int 최대값의 절반이 되어 두번 더해도 오버플로우가 나지 않게 됨

int 최대값 : 2,147,483,647

(~0U >> 2) : 1,073,741,823

좀더 보편적인 방법은 `1e9`를 최대값으로 두는 것