# 알고리즘 문제 리뷰
---
### 1285 0에 가장 가까운 거리 찾기

중복이 있으면 반영해서 출력해야 됨

`<cmath>`의 절댓값을 이용할거임

`abs()` 로 전부 양수로 바꿈

가장 거리가 먼 경우는 100000이므로 입력값이 이거보다 작으면 최소값을 갱신해주고 카운트를 1로 해줌

조회하다가 최소값이랑 같으면 카운트에 1을 더해줌

쉬웠음

### 1940 RC카 이동거리 계산하기

경우의 수는 세개임

속도를 유지하거나 가속하거나 감속하거나

속도를 유지할 경우에는 이전에 계산했던 값을 이용하면 됨

이동거리는 속도를 계속 더해주면 되니까 현재 속도만 잘 계산해주면 쉬움

속도를 유지할 경우에는 결과값에 속도만 더해줌

가속할 경우에는 속도를 먼저 더해주고 결과값에 속도를 더해줌

감속할 경우에는 속도를 빼고 음수일 경우에는 속도를 0으로 해준 다음 결과값에 속도를 더해줌

쉬웠음

### 1946 압축된 문자열 출력하기

문자와 반복개수가 쌍으로 주어짐

출력 형식은 10번째 글자마다 줄바꿈

입력 받을때부터 출력할 문자열에 .append(문자,반복횟수) 를 사용함

그후 반복문으로 한글자씩 출력하는데 10글자마다 줄바꿈 해주면 됨

### 1961 숫자 배열 회전

사전학습때 파이썬으로 풀어봤었는데 참 어려웠던 기억이 남

실력을 차근차근 쌓고 있으니 이번에는 좀 다르게 접근해봤음

반복문을 통해 입력받을 때부터 첫번째 좌표와 두번째 좌표를 잘 이용하면 90도 180도 270도 회전한 배열을 입력받을 수 있을 것 같았음

n*n이 배열의 크기이고 i와 j가 계속 증가하는 반복문일 때 다음과 같이 하면 가능함

```
[i][j] = 기본
[j][i - n - 1] = 90도
[n - 1 - i][n - 1 - j] = 180도
[n - 1 - j][i] = 270도
```

```
00    01    02

10    11    12

20    21    22


j-1 k-1    j-1 k        j-1 k+1

j k-1        j k        j k+1

j+1 k-1    j+1 k        j+1 k+1
```

그다음은 요구하는 출력 형식에 맞게 출력하면 됨

회전한 배열을 공백을 사이로 순서대로 출력해야 되니까

반복문을 2중으로 두되 두번째 반복문을 여러개 배치하면 됨

문제를 많이 풀다보니 요령이 좀 생기는 것 같았다

### 21425 +=

a b를 서로 더해서 목표값보다 크게 하기

최소 횟수를 찾아야 됨

경우는 세가지가 있을 것이다

a가 b보다 큰경우, 작은경우, 같은경우

a가 크면 b에다가 더해줘서 체급을 올려됨

b가 크면 반대로 하면 되고 같은경우에는 아무거나 상관 없음

더하고 나면 횟수 카운트 해주고 a나 b가 목표값보다 커질때까지만 반복해주면 됨

### 1206 조망권 확보

양 끝의 2칸은 비어있고 중간에는 건물의 높이가 주어짐

조망권이 확보되었다는 것은 한 건물의 같은 높이에서 양 옆 2칸이 비어있어야 한다는 것

배열 인덱스가 벗어나지 않도록 양 옆은 비어 있어서 따로 조건을 설정해주지 않아도 되었음

이중 for문으로 구성하면 건물 배열과 높이를 확인할 수 있음

건물 배열의 두번째 인덱스부터 (마지막 인덱스 - 2) 까지 조회함

그 다음은 건물 꼭대기 값에서 0이 될때까지 반복하는데

우선 양 옆이 비어있는지 확인함

`i`번째 건물을 조회하고 있으니 `i - 1`번째와 `i + 1`번째 건물을 확인

조건이 거짓이면 다음 건물 봐야되니까 `break;`

조건이 참이면 `i - 2`번째와 `i + 2`번째 건물을 확인

참이면 결과값에 하나 더해주고 거짓이면 i번째 건물은 확인할 필요가 없으니까 반복문을 빠져나와서 다음 `i + 1`번 건물을 확인하도록 `break;`

### 1208 평탄화

100개 숫자 배열이 있는데 교환을 통해 최대값과 최소값의 차이를 최대한 줄여야 함

교환은 1의 값만 가능함

입력 받은 순서는 크게 중요하지 않고 각 높이의 개수가 몇개인지만 알면 될 거임

`map<int, int>` 로 선언한 후 자료를 입력 받을 때 최대값과 최소값이 몇인지 기록하고 `map`에 입력된 키값이 없으면 값을 1로 생성, 있으면 값을 1 더해줌

교환 횟수가 0이 될때까지 다음을 반복함

최대값과 최소값을 하나씩 빼주고 (최대값 - 1)과 (최소값 + 1)의 값을 하나씩 더해줌

그후 조건 검사

최대값이 0이면 최대값을 `map`에서 지우고 최대값을 하나 빼서 갱신시켜줌

최소값도 동일한데 하나 더해주면 됨

교환을 한번 했으니 교환횟수 하나 빼주고

교환횟수가 0이 되어 반복문이 끝나면 결과값에 최대값과 최대값의 차를 넣어 출력

### 1240 암호코드 분석

0과 1로 이루어져 있다고 해서 처음에는 bool 배열로 하려고 했는데

7자리 글자가 숫자로 변환되어야 하니까 그냥 문자열로 한줄씩 입력받았음

입력 데이터 중 일부를 추출해야 하는데 추출된 암호코드는 공통점이 있음

7자리 글자 중 마지막은 무조건 1이 있음

그래서 한줄 입력받으면 마지막 문자부터 검사해서 1이 있을 경우에 (글자의 위치 - 55)부터 56글자를 빼내어 기록함

처음에는 앞에서부터 검사하고 7자리가 암호에 해당하면 추출했는데 예외 케이스가 있어 실패하는 것 같다

추출만 하면 7자리씩 변환하고 나머지 조건 검사만 하면 끝

추출하는 과정은 `map<string, int>`를 이용함