# 알고리즘 문제 리뷰
---
## 1209 2차원 배열 최댓값

[문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV13_BWKACUCFAYh)

고정된 크기의 배열이 있는데 각 행의 합, 열의 합, 대각선의 합 중 최대값을 출력하면 됨

`array[n][n]`일 때 이중 반복문으로 인덱스를 잘 전달하면 전부 구할 수 있음

i가 첫번째 반복이고 j가 두번째 반복일 때

`array[i][i]` : 우하향 대각선

`array[i][(행의 길이)-i]` : 우상향 대각선

`array[i][j]` : 행

`array[j][i]` : 열

## 1244 최대 상금

[문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD)

최대 6개의 자릿수가 있는데 각 자릿수를 교환하여 최댓값을 출력하면 됨

교환 횟수는 전부 소모해야 됨

완전 탐색을 하지 않고 풀 수 있지 않을까 고민을 많이 했던 문제

완전 탐색이 아니면 풀 수 없다고 결론내렸음

대신 전부 탐색하면 시간 초과가 나므로 빠져나올 수 있는 조건을 설정해야 함

숫자가 주어졌을 때 내림차순으로 정렬한 수가 최댓값임을 알 수 있음

하지만 교환 횟수에 따라 최댓값으로 갈 수도 있고 아닐수도 있음

최댓값에 도달했을 경우 탐색을 종료하고 남은 교환 횟수와 중복되는 수가 있는지 확인함

남은 교환 횟수가 홀수일 경우에는 1의자리와 10의자리를 교환해서 두번째 최댓값을 출력해야 하기 때문

그렇지만 중복되는 수가 있을 경우에는 남은 교환 횟수가 홀수이든 짝수이든 상관 없이 최댓값을 출력할 수 있음

탐색하는 함수의 구조는 다음과 같음

최댓값을 찾았음을 확인하는 bool 값이 참이면 함수를 종료

최댓값을 찾았다면 bool값을 참으로 변경하고 최댓값을 업데이트 해줌

그 후 남은 교환 횟수가 홀수면서 중복되는 수가 없다면 최댓값의 끝 두자리를 서로 교환

교환횟수가 0이면 현재 탐색중인 숫자가 최댓값인지 확인

조건 확인은 이게 다고 탐색 부분은 다음과 같음

이중 반복문으로 다음과 같이 교환함

```
인덱스가 다음과 같을 때
0   1   2   3

(0,1) 함수호출 (0,2) 함수호출 (0,3) 함수호출 ... (1,2) 함수호출 (1,3) 함수호출 ... (2,3) 함수호출
```

교환이 한번 일어나게 되는 순간 탐색함수를 재귀적으로 호출하는데 현재 숫자와 함께 교환횟수는 1을 빼고 호출함

그 후 다음 교환이 일어나기 전에 다시 원상복구를 함

왜냐하면 그래야만 모든 경우의 수를 확인할 수 있기 때문임

저렇게 계속 호출 하다가 조건에 맞게 되면 탐색을 전부 중지하게 되고 답을 출력하는 것

## 1242 암호코드 업그레이드

[문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15JEKKAM8CFAYD) 

[S/W 문제해결] 시리즈가 있는 것 같길래 1일차부터 클리어 해보자 싶어서 덤볐다가 굉장히 힘들었음

처음 시도해본 D5 문제

이전에 했던 암호코드와 비슷하지만 난이도가 훨씬 더 어렵다

해결해야 되는 문제들은 다음과 같음

16진수로 주어지는 수를 2진수로 변환해야 함

예를들어 16진수 C를 2진수로 변환한다면 1100으로 변환됨

근데 암호코드의 마지막 부분은 0이 올수 없으므로 가장 뒷부분의 0은 잘라내고 앞부분의 길이와 맞춰야 함

정상적인 암호가 여러개일 수도 있고 비정상적인 암호도 여러개일 수 있음

게다가 암호코드의 길이가 가변적으로 변할 수 있음

암호코드의 길이가 가변적이라는 것 때문에 머리가 너무 아팠다

조건이 많다보니 코드도 복잡해졌는데 하나씩 암호 추출 과정을 설명해보겠다

`int loop = 1` 선언해줌

이것은 암호코드의 길이가 가변적이지만 56배수의 길이를 가진다는 것을 이용해 암호코드가 변환이 안되는 이상한 코드일 경우 loop를 점점 증가시켜 탐색을 이어나가기 위함임

중복되는 코드가 많기 때문에 입력받은 코드가 이전 코드와 동일할 경우에는 반복문을 넘어갈 것임

동일하지 않다면 이전 코드를 업데이트 해주고 문자열을 추출하는 함수로 인수를 넘겨줌

첫번째 함수에서는 우선 입력받은 문자열을 2진수로 변환함

2진수로 변환을 먼저 하는 이유는 가장 마지막이 1로 끝나는 56배수의 자리여야 하기 때문인데 16진수인 상태에서는 그것을 확인하기가 어려웠기 때문임

2진수로 변환하는 것은 문자열을 순회하며 0부터 F까지 10진수의 값으로 바꾼 후 `bitset`을 이용해 2진수로 바꾸는 것임

2진수로 변환된 문자열을 끝에서부터 순회하는데 1인 경우를 찾을 것임

1이라면 추출을 시작하는데 다음과 같이 함

`(인덱스 - 56 * loop + 1)의 위치부터 (56 * loop) 만큼의 글자수를 추출`

추출된 문자열은 유효성을 확인하는 함수로 넘겨줌

암호는 8자리니까 한자리당 `(7 * loop)`만큼의 길이가 될 것임

길이가 가변적이라서 암호 변환은 비율로 계산하기로 했음

따라서 0과 1을 순차적으로 세주면서 loop 횟수만큼 나눠주면 비율이 나오게 됨

그 후에 0과 1의 비율을 숫자로 바꿔주는 코드에서 다른 값이 나오면 잘못된 값이 나왔다고 리턴함

그렇게 계속 거슬러 올라가며 리턴 하다가 맨 처음 문자열을 추출하는 함수에서 loop를 1 더해주고 문자열 검색 위치를 그대로 유지시켜 줌

그렇게 하다가 올바른 코드가 나왔다면 이전에 확인한 코드인지 확인하고 처음 본 코드라면 코드를 기록해줌

이전에 확인한 코드라면 true로 리턴한 후 코드의 길이만큼 문자열 검색 인덱스를 당겨준 뒤 loop를 1로 초기화 함

다시 처음 본 코드라면 올바른 코드인지 검증하고 맞다면 결과값에 더해줌

그 다음에 true로 리턴한 후 이전에 확인한 코드일때와 똑같은 분기로 넘어감

올바른 코드가 아니어도 true로 리턴

그후 계속 탐색 반복임

여기서부터는 잡설

처음에 제출하고 테스트 케이스 많이 틀렸길래 이유를 찾다보니 올바른 코드는 전부 합해야 한다는 것을 나중에 발견했음

난이도가 올라가니 꽤 힘들었지만 예전에 유니티 작업하면서 문제 찾고 해결하는 과정이 생각나기도 해서 재밌기도 했다

결국 해냈을 때에는 짜릿했음

앞으로 계속 나아가보자

## c++ 범위 기반 for문

```c++
for ([현재 요소를 저장할 변수] : [반복 가능한 객체]) 
{
    실행할 내용
}
```

파이썬의 `for item in list`랑 비슷한 것 같음